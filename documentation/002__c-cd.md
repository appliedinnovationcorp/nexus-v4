# Building Nexus V4: Part 2 CI/CD

Deciding whether to set up CI/CD (Continuous Integration/Continuous Deployment) early or later depends on your project’s goals, complexity, and development workflow. Since we’re building a web application starting with a Turborepo monorepo, let’s evaluate the pros and cons of setting up CI/CD now versus later, and then we’ll detail the approach we took tailored to our current project state.

---

### Pros and Cons of Setting Up CI/CD Now vs. Later

#### Setting Up CI/CD Now
**Pros**:
- **Early Automation**: Automates tasks like linting, building, and testing, catching issues early (e.g., lint errors, build failures).
- **Consistency**: Ensures every commit is validated, maintaining code quality as the project grows.
- **Deployment Foundation**: Sets up a deployment pipeline (e.g., to Vercel, Netlify, or AWS) early (e.g. making it easier to deploy the `apps/web` or `apps/docs` Next.js apps).
- **Team Collaboration**: If you plan to collaborate, CI/CD ensures contributors follow standards (e.g., passing tests before merging).
- **Time Savings Long-Term**: Early setup avoids manual checks and reduces future refactoring.

**Cons**:
- **Initial Overhead**: Takes time to configure (e.g., writing GitHub Actions workflows, setting up a deployment platform).
- **Limited Codebase**: With only a Turborepo scaffold, there’s little code to test or deploy, so CI/CD may feel premature.
- **Maintenance**: CI/CD pipelines require updates as the project evolves (e.g., new scripts, dependencies).

#### Setting Up CI/CD Later
**Pros**:
- **Focus on Development**: Lets you prioritize building the app (e.g., customizing `apps/web`, adding features) without CI/CD setup distraction.
- **Clearer Requirements**: Waiting until you have a backend, database, or more features helps tailor the CI/CD pipeline to specific needs (e.g., database migrations, API tests).
- **Simpler Early Workflow**: Avoids configuring pipelines for a minimal codebase that may change significantly.

**Cons**:
- **Delayed Quality Checks**: Without CI, you might miss linting or build issues until manual testing.
- **Manual Deployments**: Deploying to a hosting platform (e.g., Vercel) manually can be error-prone or time-consuming.
- **Technical Debt**: Delaying CI/CD might lead to inconsistent code quality or harder-to-fix issues later.

---

### Recommendation: Set Up Basic CI Now, Defer Full CD
Given our project’s current state (a Turborepo monorepo with a Git repository and a basic `README.md`), I chose setting up a **basic CI pipeline now** but deferring full **CD (deployment)** until you’ve built out more of the application (e.g., after customizing `apps/web` or adding a backend). Here’s why:
- **Why CI Now?**
  - The monorepo already has scripts like `pnpm run lint` and `pnpm run build` (from Turborepo’s scaffold). A CI pipeline can automatically run these on every push or pull request, ensuring code quality without much effort.
  - It’s lightweight to set up for a Turborepo project, leveraging existing scripts.
  - Early CI catches issues like TypeScript errors or linting violations as I customize `apps/web`.
- **Why Defer CD?**
  - At the moment the app is in its infancy (just a scaffold). I haven’t yet defined the app’s purpose or deployment needs (e.g., Vercel for Next.js, AWS for a backend).
  - Setting up CD requires choosing a hosting platform and configuring deployments, which is premature without a functional app.
  - I can manually deploy the `web` app to Vercel or Netlify later with minimal effort once it’s ready.

This approach balances early quality assurance with minimal setup overhead, keeping me focused on development.

---

### Step-by-Step Guide to Set Up Basic CI with GitHub Actions

I'll first set up a simple GitHub Actions workflow to run linting and building on every push and pull request. This assumes your repository is on GitHub (if you’re using GitLab, Bitbucket, or another platform you'll have to adjust the instructions).

#### 1. Create a GitHub Actions Workflow
1. **Create Workflow Directory**:
   In your project root (`my-web-app`), create a directory for GitHub Actions:
   ```bash
   mkdir -p .github/workflows
   ```

2. **Create CI Workflow File**:
   Create `.github/workflows/ci.yml` with the following content:
   ```yaml
   name: CI

   on:
     push:
       branches:
         - main
         - dev
     pull_request:
       branches:
         - main
         - dev

   jobs:
     lint:
       runs-on: ubuntu-latest
       steps:
         - name: Checkout code
           uses: actions/checkout@v4

         - name: Set up Node.js
           uses: actions/setup-node@v4
           with:
             node-version: '20'
             cache: 'pnpm'

         - name: Install dependencies
           run: pnpm install

         - name: Run lint
           run: pnpm run lint

     build:
       runs-on: ubuntu-latest
       steps:
         - name: Checkout code
           uses: actions/checkout@v4

         - name: Set up Node.js
           uses: actions/setup-node@v4
           with:
             node-version: '20'
             cache: 'pnpm'

         - name: Install dependencies
           run: pnpm install

         - name: Run build
           run: pnpm run build
   ```
   - **Explanation**:
     - Triggers on `push` and `pull_request` to `main` and `dev` branches.
     - Two jobs: `lint` (runs `pnpm run lint`) and `build` (runs `pnpm run build`).
     - Uses `actions/checkout@v4` to clone the repo and `actions/setup-node@v4` to set up Node.js 20 with pnpm caching for faster runs.
     - Runs `pnpm install` to install dependencies, then executes the respective scripts.

#### 2. Commit and Push the Workflow
1. **Stage the Workflow File**:
   ```bash
   git add .github/workflows/ci.yml
   ```

2. **Commit**:
   ```bash
   git commit -m "Add GitHub Actions CI workflow for linting and building"
   ```

3. **Push to Remote**:
   ```bash
   git push origin main
   ```
   (Or `dev` if you’re working on a development branch.)

#### 3. Verify the CI Pipeline
1. Go to your GitHub repository.
2. Click the **Actions** tab.
3. You should see the `CI` workflow running for the latest push.
4. Check the `lint` and `build` jobs to ensure they pass. If they fail (e.g., due to linting errors), review the logs and fix issues locally.

#### 4. (Optional) Update `.gitignore`
Ensure `.github/workflows/` is not ignored (it shouldn’t be by default). Verify your `.gitignore` includes build artifacts and caches:
```gitignore
.turbo/
.next/
node_modules/
pnpm-lock.yaml
```
Your existing `.gitignore` (from the Turborepo scaffold) likely covers these, but double-check.

#### 5. (Optional) Add a Status Badge to `README.md`
Add a badge to your `README.md` to show CI status:
1. Open `README.md` and add this near the top (replace `your-username` and `my-web-app`):
   ```markdown
   # My Web App

   [![CI](https://github.com/your-username/my-web-app/actions/workflows/ci.yml/badge.svg)](https://github.com/your-username/my-web-app/actions/workflows/ci.yml)
   ```
2. Commit and push:
   ```bash
   git add README.md
   git commit -m "Add CI status badge to README"
   git push origin main
   ```

---

### Why This CI Setup?
- **Lightweight**: Only runs `lint` and `build`, which are already defined in your Turborepo scaffold.
- **Scalable**: You can later add jobs for testing, deployment, or other tasks (e.g., when you add a backend or tests).
- **Turborepo-Friendly**: Leverages Turborepo’s caching (via `pnpm`) for faster CI runs.
- **Immediate Feedback**: Ensures every push/pull request maintains code quality.

---

### When to Add CD?
Revisit CD setup after you’ve:
- Customized `apps/web` with a functional frontend (e.g., after adding Tailwind CSS and a layout, as previously suggested).
- Defined your app’s purpose (e.g., portfolio, e-commerce) and hosting needs (e.g., Vercel for Next.js).
- Optionally added a backend (`apps/api`) or database, requiring deployment configurations.

A simple CD setup for the `web` app could involve Vercel, which integrates seamlessly with Next.js:
- Connect your GitHub repo to Vercel.
- Configure automatic deployments on `main` pushes.
- This can be done in ~10 minutes once the app is ready.

---

### Next Steps
With basic CI in place, I recommend proceeding with **customizing the `